這是一份\*\*「開發合約 (Contract)」\*\*。

為了讓後端開發人員與前端 UI可以直接開工互不等待，我將所有需要協調的 **UiState (資料狀態)** 和 **ViewModel Event (操作介面)** 定義好了。

-----

### 共用資料模型 (Data Transfer Objects)

為了避免 UI 層直接操作資料庫 Entity，先定義一個「表單專用」的資料類別。這是 UI 輸入框會綁定的變數。

```kotlin
// 放在 data/UiModels.kt

/**
 * 用於 UI 表單輸入的暫存物件，所有欄位都是 String 以防輸入時報錯
 * 真正存入 DB 前再轉型
 */
data class TemplateDetails(
    val id: Int = 0,
    val name: String = "",
    val image: String = "",
    val ports: String = "",       // ex: "8080:80"
    val volumes: String = "",     // ex: "./data:/app"
    val envVars: String = "",     // ex: "KEY=VALUE" (換行分隔)
    val restartPolicy: String = "no" // V2 Migration: "no", "always", "on-failure"
)

/**
 * 擴充函式：將 Entity 轉為 UI Details
 */
fun ServiceTemplate.toTemplateDetails(): TemplateDetails = TemplateDetails(
    id = id,
    name = name,
    image = image,
    ports = ports,
    volumes = volumes,
    envVars = envVars,
    restartPolicy = restartPolicy
)

/**
 * 擴充函式：將 UI Details 轉回 Entity (準備存入 DB)
 */
fun TemplateDetails.toServiceTemplate(): ServiceTemplate = ServiceTemplate(
    id = id,
    name = name,
    image = image,
    ports = ports,
    volumes = volumes,
    envVars = envVars, // 這裡你之後可以加邏輯把換行轉 JSON
    restartPolicy = restartPolicy
)
```

-----

### 1\. 首頁列表 (Home / List Screen)

這是最繁忙的頁面，包含列表顯示、搜尋、同步。

#### **HomeUiState (給 UI 讀)**

```kotlin
data class HomeUiState(
    // 資料列表 (直接給 UI Render)
    val templateList: List<ServiceTemplate> = emptyList(),
    
    // 搜尋關鍵字 (綁定搜尋框)
    val searchQuery: String = "",
    
    // 讀取狀態 (顯示 Loading Spinner)
    val isLoading: Boolean = false,
    
    // 錯誤訊息 (顯示 Toast 或 SnackBar，null 代表沒事)
    val userMessage: String? = null
)
```

#### **HomeViewModel 介面 (給 UI 呼叫)**

```kotlin
interface HomeEventActions {
    // 當使用者在搜尋框打字時
    fun onSearchQueryChanged(query: String)
    
    // 當使用者滑動刪除某個項目
    fun onDeleteTemplate(template: ServiceTemplate)
    
    // 當使用者點擊「雲端同步」按鈕
    fun onSyncWithCloud()
    
    // 消耗掉錯誤訊息 (讓 Toast 不會一直跳)
    fun onMessageShown()
}
```

-----

### 2\. 新增/編輯頁 (Entry / Edit Screen)

這是表單輸入頁面，重點在「驗證」與「暫存輸入」。

#### **ItemEntryUiState (給 UI 讀)**

```kotlin
data class ItemEntryUiState(
    // 表單目前的內容
    val itemDetails: TemplateDetails = TemplateDetails(),
    
    // 表單是否有效？(決定 Save 按鈕是否亮起)
    // 規則：Name 和 Image 不能為空
    val isEntryValid: Boolean = false,
    
    // 儲存狀態 (避免重複點擊)
    val isSaving: Boolean = false
)
```

#### **ItemEntryViewModel 介面 (給 UI 呼叫)**

```kotlin
interface ItemEntryEventActions {
    // 當使用者在任何 TextField 輸入時呼叫，更新 State
    fun updateUiState(details: TemplateDetails)
    
    // 當使用者點擊「儲存」
    fun saveItem()
    
    // 當使用者選擇 Restart Policy (V2 功能)
    fun onRestartPolicyChanged(policy: String)
}
```

-----

### 3\. 詳細資料頁 (Detail Screen)

這是你的核心亮點頁面，包含 YAML 生成。

#### **ItemDetailUiState (給 UI 讀)**

```kotlin
data class ItemDetailUiState(
    // 當前顯示的資料
    val templateDetails: TemplateDetails = TemplateDetails(),
    
    // 生成出來的 YAML 字串 (顯示在唯讀框)
    val generatedYaml: String = "",
    
    // 是否正在上傳到雲端
    val isUploading: Boolean = false,
    
    // 雲端操作結果訊息
    val cloudMessage: String? = null
)
```

#### **ItemDetailViewModel 介面 (給 UI 呼叫)**

```kotlin
interface ItemDetailEventActions {
    // 當進入頁面時，或使用者點擊「生成」按鈕
    fun generateYaml()
    
    // 複製到剪貼簿後 (可選，用來顯示 "已複製" 提示)
    fun onCopyYaml()
    
    // 點擊「上傳此 Template 到雲端」
    fun uploadToCloud()
}
```

-----

### 實作指引

**UI 開發:**

1.  可以直接在 `Composable` 函式中使用這些 State。
2.  他不需要後端寫好 Database，可以先在 ViewModel 裡塞 **假資料 (Fake Data)** 來測試畫面排版。
      * *例如：直接讓 ListState 回傳 3 個寫死的 ServiceTemplate。*

**後端開發:**

1.  你去實作真正的 `ViewModel` class。
2.  繼承並實作上述的 Function。
3.  連接你的 `Repository` 和 `DAO`。

**範例：如何實作 HomeViewModel (部分)**

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val templatesRepository: TemplatesRepository
) : ViewModel() {

    // 使用 StateFlow 讓 UI 訂閱
    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()

    // 實作介面邏輯
    fun onSearchQueryChanged(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
        // 這裡觸發 DAO 的搜尋 Flow
        fetchTemplates(query)
    }
    
    // ... 其他實作
}
